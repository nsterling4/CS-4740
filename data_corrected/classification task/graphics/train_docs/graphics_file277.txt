From : lusardi@cs.buffalo.edu ( Christopher Lusardi ) Subject : Program Included : 2 Edge Detection Algorithms ! / * This program doesn't detect edges with compass operators and a laplacian operator . It should output 2 raw grey-scale images with edges . The output doesn't look like edges at all . In novicee terms , how do I correct the errors ? Any improvements are welcome . ( I'll even accept your corrected code . ) ( If I convolve the INPUT.IMAGE with a digital gaussian [ 7 by 7 ] to remove noise , will I get an improvement with the laplacian . ) - - - 2 types of edge detection - - - * / #include <stdio.h> #include <math.h> #define IMAGEWIDTH 300 #define IMAGEHEIGHT 300 unsigned char Input_Image [ IMAGEHEIGHT ] [ IMAGEWIDTH ]; unsigned char Angles_Wanted [ IMAGEHEIGHT ] [ IMAGEWIDTH ]; unsigned char Magnitude_Image [ IMAGEHEIGHT ] [ IMAGEWIDTH ]; int Laplace_Op 1 [ 3 ] [ 3 ] = { 0 , - 1 , 0 , -1,4 , - 1 , 0 , - 1 , 0 }; int Compass_Op 1 [ 3 ] [ 3 ] = { 1 , 1 , 1 , 0,0 , 0 , - 1 , - 1 , - 1 }; int Compass_Op 2 [ 3 ] [ 3 ] = { 1 , 1 , 0 , 1,0 , - 1 , 0 , - 1 , - 1 }; int Compass_Op 3 [ 3 ] [ 3 ] = { 1 , 0 , - 1 , 1,0 , - 1 , 1 , 0 , - 1 }; int Compass_Op 4 [ 3 ] [ 3 ] = { 0 , - 1 , - 1 , 1,0 , - 1 , 1 , 1 , 0 }; int Compass_Op 5 [ 3 ] [ 3 ] = { - 1 , - 1 , - 1 , 0,0 , 0 , 1 , 1 , 1 }; int Compass_Op 6 [ 3 ] [ 3 ] = { - 1 , - 1 , 0 , -1,0 , 1 , 0 , 1 , 1 }; int Compass_Op 7 [ 3 ] [ 3 ] = { - 1 , 0 , 1 , -1,0 , 1 , - 1 , 0 , 1 }; int Compass_Op 8 [ 3 ] [ 3 ] = { 0 , 1 , 1 , -1,0 , 1 , - 1 , - 1 , 0 }; void Compass ( row , col ) int row , col ; { int value ; int op_rows , op_cols ; int Compass 1 , Compass 2 , Compass 3 , Compass 4 ; int Compass 5 , Compass 6 , Compass 7 , Compass 8 ; Compass 1 = Compass 2 = Compass 3 = Compass 4 = 0 ; Compass 5 = Compass 6 = Compass 7 = Compass 8 = 0 ; for ( op_rows = - 1 ; op_rows < 2 ; op_rows + + ) for ( op_cols = - 1 ; op_cols < 2 ; op_cols + + ) { if ( ( ( row + op_rows ) > = 0 ) & & ( ( col + op_cols ) > = 0 ) ) { Compass 1 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 1 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 2 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 2 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 3 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 3 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 4 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 4 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 5 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 5 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 6 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 6 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 7 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 7 [ op_rows + 1 ] [ op_cols + 1 ]; Compass 8 + = ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] ) * Compass_Op 8 [ op_rows + 1 ] [ op_cols + 1 ]; } } if ( Compass 1 < Compass 2 ) value = Compass 2 ; else value = Compass 1 ; if ( value < Compass 3 ) value = Compass 3 ; if ( value < Compass 4 ) value = Compass 4 ; if ( value < Compass 5 ) value = Compass 5 ; if ( value < Compass 6 ) value = Compass 6 ; if ( value < Compass 7 ) value = Compass 7 ; if ( value < Compass 8) value = Compass 8 ; Magnitude_Image [ row ] [ col ] = ( char ) value ; } void Laplace 1 ( row , col ) int row , col ; { int op_rows , op_cols ; Magnitude_Image [ row ] [ col ] = 0 ; for ( op_rows = - 1 ; op_rows < 2 ; op_rows + + ) for ( op_cols = - 1 ; op_cols < 2 ; op_cols + + ) if ( ( ( row + op_rows ) > = 0 ) & & ( ( col + op_cols ) > = 0 ) ) Magnitude_Image [ row ] [ col ] = ( char ) ( ( int ) Magnitude_Image [ row ] [ col ] + ( ( int ) Input_Image [ row + op_rows ] [ col + op_cols ] * Laplace_Op 1 [ op_rows + 1 ] [ op_cols + 1 ] ) ); } main ( ) { FILE * Original_Image_fp ; FILE * Laplace 1_mag_fp , * Laplace 2_mag_fp , * Laplace 3_mag_fp ; FILE * Compass_mag_fp ; int row , col , Algo_Count ; Original_Image_fp = fopen ( " INPUT.IMAGE " , " rb " ); Laplace 1_mag_fp = fopen ( " Laplace 1_Magnitude " , " wb " ); Compass_mag_fp = fopen ( " Compass_Magnitude " , " wb " ); fread ( ( unsigned char * ) Input_Image , sizeof ( unsigned char ) , IMAGEHEIGHT * IMAGEWIDTH , Original_Image_fp ); for ( Algo_Count = 0 ; Algo_Count < 2 ; Algo_Count + + ) { for ( row = 0 ; row < IMAGEHEIGHT ; row + + ) for ( col = 0 ; col < IMAGEWIDTH ; col + + ) if ( ! Algo_Count ) Laplace 1 ( row , col ); else Compass ( row , col ); if ( ! Algo_Count ) fwrite ( Magnitude_Image , sizeof ( char ) , IMAGEHEIGHT * IMAGEWIDTH , Laplace 1_mag_fp ); else fwrite ( Magnitude_Image , sizeof ( char ) , IMAGEHEIGHT * IMAGEWIDTH , Compass_mag_fp ); } } - - | . - , # # # | For a lot of . au music : ftp sounds.sdsu.edu | / / __ , _ # # # | then cat file.au > / dev / audio | \ _ > / > _ / ( _ / \ _ / < > _ | UB library catalog : telnet bison.acsu.buffalo.edu | _ 14261 _ | ( When in doubt ask : xarchie , xgopher , or xwais . )